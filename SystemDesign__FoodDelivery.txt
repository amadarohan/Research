System Design for: 'Food Delivery App like DoorDash'

This document outlines the architectural design for a scalable food delivery application similar to DoorDash. The system must handle a high volume of orders, real-time tracking of drivers and orders, efficient matching of orders to drivers, and seamless interactions between customers, restaurants, and drivers, all while maintaining low latency and high availability.

### C4 Model Diagrams

#### 1\. System Context Diagram

The System Context diagram provides a high-level view of the Food Delivery App and its interactions with external users and systems. It shows the core platform interacting with customers, restaurants, drivers, and various third-party services.

**Description:**

  * **Customer:** A person who browses restaurants, places orders, tracks deliveries, and makes payments via the mobile app.
  * **Restaurant:** A business that receives orders, prepares food, and communicates readiness to the platform.
  * **Driver:** A person who accepts delivery requests, picks up food from restaurants, and delivers it to customers.
  * **Food Delivery App (System in Scope):** The central platform that facilitates the ordering, delivery, and payment process.
  * **Third-Party Payment Gateway:** An external service that securely processes credit card and other payments.
  * **Third-Party Map Service:** An external system (e.g., Google Maps) that provides geocoding, routing, and real-time traffic information.
  * **SMS Gateway:** An external service that sends SMS notifications to customers, restaurants, and drivers.

**Mermaid.js Code:**

```mermaid
C4Context
    title System Context Diagram for Food Delivery App

    Person(customer, "Customer", "Orders food and tracks delivery.")
    Person(restaurant, "Restaurant", "Prepares food and receives orders.")
    Person(driver, "Driver", "Picks up and delivers food.")
    
    System(food_delivery_app, "Food Delivery App", "The core platform for food ordering and delivery.")
    
    System_Ext(payment_gateway, "Payment Gateway", "Processes payments securely.")
    System_Ext(map_service, "Third-Party Map Service", "Provides mapping, routing, and geocoding.")
    System_Ext(sms_gateway, "SMS Gateway", "Sends SMS notifications.")

    Rel(customer, food_delivery_app, "Places orders via")
    Rel(restaurant, food_delivery_app, "Manages orders via")
    Rel(driver, food_delivery_app, "Accepts/manages deliveries via")
    Rel(food_delivery_app, payment_gateway, "Processes payments via")
    Rel(food_delivery_app, map_service, "Gets map/route data from")
    Rel(food_delivery_app, sms_gateway, "Sends notifications via")
```

-----

#### 2\. Container Diagram

This diagram zooms into the Food Delivery App system, showing the major independently deployable components. The design uses a microservices architecture to handle the complex, real-time interactions.

**Description:**

  * **Customer App/Web:** The mobile or web application used by customers to browse, order, and track deliveries.
  * **Restaurant App/Portal:** The application or web portal used by restaurants to receive orders, update status, and manage their menu.
  * **Driver App:** The mobile application used by drivers to accept orders, navigate, and update delivery status.
  * **API Gateway:** The single entry point for all client requests. It handles authentication, rate limiting, and routes requests to the appropriate microservices.
  * **User Service:** Manages user profiles (customers, restaurants, drivers), authentication, and account data.
  * **Order Service:** The core microservice that manages the lifecycle of an order (creation, processing, assignment, delivery, completion).
  * **Restaurant Service:** Manages restaurant details, menus, availability, and pricing.
  * **Driver Location Service:** A high-throughput, real-time service that tracks the live GPS location of all active drivers.
  * **Matching Service:** A specialized service that efficiently matches new orders with available and suitable drivers.
  * **Payment Service:** Handles all payment-related logic and communicates with the third-party Payment Gateway.
  * **Notification Service:** Sends real-time notifications to customers, restaurants, and drivers via SMS or push notifications.
  * **Geospatial Database:** A specialized data store optimized for storing and querying geographical data (e.g., driver locations, restaurant locations).
  * **Order Database:** A relational or document database that stores order history, status, and details.
  * **Menu Database:** A database that stores restaurant menus and associated items.

**Mermaid.js Code:**

```mermaid
C4Container
    title Container Diagram for Food Delivery App

    Person(customer, "Customer")
    Person(restaurant, "Restaurant")
    Person(driver, "Driver")
    System_Ext(map_service, "Third-Party Map Service")
    System_Ext(payment_gateway, "Payment Gateway")
    System_Ext(sms_gateway, "SMS Gateway")
    
    System_Boundary(food_delivery_app_boundary, "Food Delivery App") {
        Container(customer_client, "Customer App/Web", "iOS, Android, Web App", "User interface for ordering food.")
        Container(restaurant_client, "Restaurant App/Portal", "Web Portal/Tablet App", "Interface for managing orders.")
        Container(driver_client, "Driver App", "iOS, Android App", "Interface for managing deliveries.")
        Container(api_gateway, "API Gateway", "Go/NGINX", "Routes API calls and handles auth.")
        
        Container(user_service, "User Service", "Java", "Manages user profiles (C/R/D).")
        Container(order_service, "Order Service", "Python", "Manages the order lifecycle.")
        Container(restaurant_service, "Restaurant Service", "Node.js", "Manages restaurant details and menus.")
        Container(driver_location_service, "Driver Location Service", "Go", "Tracks driver locations in real-time.")
        Container(matching_service, "Matching Service", "Java/C++", "Matches orders with drivers.")
        Container(payment_service, "Payment Service", "Python", "Handles all payment logic.")
        Container(notification_service, "Notification Service", "Node.js", "Sends real-time notifications.")

        ContainerDb(user_db, "User DB", "PostgreSQL", "Stores customer, restaurant, driver profiles.")
        ContainerDb(order_db, "Order DB", "MongoDB", "Stores order history and status.")
        ContainerDb(menu_db, "Menu DB", "PostgreSQL", "Stores restaurant menus.")
        ContainerDb(geo_db, "Geospatial DB", "Redis/Cassandra", "Stores real-time driver locations.")
    }
    
    Rel(customer, customer_client, "Uses")
    Rel(restaurant, restaurant_client, "Uses")
    Rel(driver, driver_client, "Uses")

    Rel(customer_client, api_gateway, "Makes API calls to", "HTTPS")
    Rel(restaurant_client, api_gateway, "Makes API calls to", "HTTPS")
    Rel(driver_client, api_gateway, "Makes API calls to", "HTTPS")

    Rel(api_gateway, user_service, "Routes auth/profile API calls to")
    Rel(api_gateway, order_service, "Routes order API calls to")
    Rel(api_gateway, restaurant_service, "Routes restaurant/menu API calls to")
    Rel(api_gateway, driver_location_service, "Routes driver location updates to")
    
    Rel(order_service, user_db, "Queries customer/driver info from")
    Rel(order_service, order_db, "Saves/updates order status in")
    Rel(order_service, restaurant_service, "Queries restaurant info/menu from")
    Rel(order_service, matching_service, "Sends order for driver assignment to")
    Rel(matching_service, geo_db, "Queries for nearby drivers from")
    Rel(matching_service, order_service, "Returns driver assignment to")
    Rel(order_service, payment_service, "Initiates payment with")
    Rel(order_service, notification_service, "Sends order updates via")
    
    Rel(driver_location_service, geo_db, "Writes real-time location data to")
    Rel(driver_location_service, map_service, "Uses for geocoding")
    Rel(payment_service, payment_gateway, "Processes payments via")
    Rel(notification_service, sms_gateway, "Sends SMS via")
    Rel(notification_service, api_gateway, "Sends Push Notifications via")
```

-----

#### 3\. Component Diagram (Order Service)

This diagram focuses on the internal components of the **Order Service** container, illustrating how it handles the creation and initial processing of a new food order.

**Description:**

  * **API Controller:** The entry point for the Order Service. It receives new order requests from the API Gateway.
  * **Order Validator:** A component that checks the incoming order payload for correctness, availability (e.g., restaurant open, items in stock), and fraud.
  * **Order Persister:** A component that saves the new order details into the Order Database.
  * **Matching Service Client:** A component that initiates the driver assignment process by sending the new order to the Matching Service.
  * **Notification Publisher:** A component that publishes events related to the order (e.g., "Order Placed", "Order Ready for Pickup") to a message queue or directly to the Notification Service for dispatch to relevant parties.
  * **Menu Service Client:** A component that queries the Restaurant Service to validate menu items and prices.

**Mermaid.js Code:**

```mermaid
C4Component
    title Component Diagram for Order Service

    Container(api_gateway, "API Gateway")
    Container_Ext(restaurant_service, "Restaurant Service")
    Container_Ext(matching_service, "Matching Service")
    Container_Ext(notification_service, "Notification Service")
    ContainerDb(order_db, "Order DB", "MongoDB")

    Container_Boundary(order_service, "Order Service") {
        Component(api_controller, "API Controller", "REST Endpoint", "Receives new order requests.")
        Component(order_validator, "Order Validator", "Business Logic", "Validates order details and availability.")
        Component(order_persister, "Order Persister", "MongoDB Client", "Saves new orders to the Order DB.")
        Component(matching_client, "Matching Service Client", "gRPC Client", "Sends order to matching service.")
        Component(notification_publisher, "Notification Publisher", "Kafka Producer", "Publishes order events.")
        Component(menu_client, "Menu Service Client", "gRPC Client", "Queries menu for validation.")
    }
    
    Rel(api_gateway, api_controller, "Sends new order request to", "HTTPS")
    Rel(api_controller, order_validator, "Passes order for validation to")
    Rel(order_validator, menu_client, "Queries menu details from")
    Rel(menu_client, restaurant_service, "Retrieves menu data from")
    Rel(order_validator, order_persister, "Sends validated order to")
    Rel(order_persister, order_db, "Writes new order to")
    Rel(order_persister, matching_client, "Notifies matching service of new order")
    Rel(matching_client, matching_service, "Sends order for driver assignment to")
    Rel(order_persister, notification_publisher, "Publishes 'Order Placed' event to")
    Rel(notification_publisher, notification_service, "Sends notification to")
```

-----

### Architecture Decision Record

#### ADR 1: Implement an Event-Driven Architecture for Real-time Updates and Decoupling

**Status:** Proposed

**Context:**
A food delivery application involves many interacting components (customer app, restaurant portal, driver app, various backend services) and requires real-time updates for order status, driver location, and notifications. A purely synchronous, request-response architecture would lead to tight coupling, increased latency, and potential bottlenecks, especially during peak hours. Ensuring all parties are aware of critical state changes (e.g., "order picked up," "driver nearby") in real-time is crucial for a smooth user experience.

**Decision:**
We will adopt an **Event-Driven Architecture (EDA)** using a distributed message broker (e.g., Apache Kafka). Key state changes within services (e.g., `Order Placed`, `Driver Accepted Order`, `Food Picked Up`, `Driver Arrived`) will be published as events to dedicated topics in the message broker. Other interested services will subscribe to these topics and react asynchronously. This decouples services, allows for real-time processing, and enables features like real-time tracking and notifications.

**Consequences:**

  * **Positive:**

      * **Real-time Updates:** Enables real-time communication between services, ensuring customers, restaurants, and drivers receive immediate updates on order and delivery status.
      * **Loose Coupling:** Services operate independently, reacting to events without direct knowledge of other services' implementations. This improves maintainability and allows for independent deployment.
      * **Scalability:** The message broker can buffer events, allowing producers and consumers to scale independently to handle varying loads. It prevents bottlenecks in one service from cascading to others.
      * **Resilience:** If a consumer service goes down, messages remain in the queue and can be processed once it recovers, preventing data loss and ensuring eventual consistency.
      * **Extensibility:** New features or services can easily be added by subscribing to existing events without modifying existing services.

  * **Negative:**

      * **Increased Complexity:** Event-driven systems introduce complexity in terms of event schema management, potential for event storms, ensuring idempotent consumers, and distributed tracing/debugging.
      * **Eventual Consistency:** Data across different services becomes eventually consistent rather than immediately consistent. This requires careful design to handle scenarios where data might be temporarily out of sync.
      * **Operational Overhead:** Managing and monitoring a distributed message broker (like Kafka) requires specialized expertise and infrastructure.

**Alternatives Considered:**

  * **Pure Synchronous RESTful API Calls:** All services communicate directly via REST APIs. This is simpler to implement initially but would lead to tight coupling, reduced scalability under high load, and cascading failures if a service is slow or unavailable. Real-time updates would require polling, which is inefficient. This was rejected due to scalability and reliability concerns.
  * **Polling-Based Updates:** Clients constantly poll backend services for updates. While simpler to implement for clients, it's highly inefficient, wastes resources (network bandwidth, server CPU), and introduces significant latency for real-time changes. This was rejected for inefficiency and poor user experience.
