System Design for: 'Google Maps'

This document outlines the architectural design for a scalable and real-time mapping service like Google Maps. The system is designed to handle a massive volume of geospatial data, provide low-latency routing and search functionalities, and integrate real-time traffic information to offer an accurate and dynamic user experience.

### C4 Model Diagrams

#### 1\. System Context Diagram

The System Context diagram provides a high-level view of the Google Maps system and its interactions with external users and systems. It shows the core service interacting with users, businesses, and various external data providers.

**Description:**

  * **User:** A person who uses the Google Maps application on their phone or web browser to find places, get directions, and explore maps.
  * **Business:** A business that manages its profile on the platform (e.g., location, hours, photos).
  * **External Data Providers:** Third-party systems that supply real-time information such as traffic data, public transit schedules, and satellite imagery.
  * **Google Maps (System in Scope):** The central platform that processes and serves map data, handles routing, and provides search functionality.

**Mermaid.js Code:**

```mermaid
C4Context
    title System Context Diagram for Google Maps

    Person(user, "User", "Gets directions, finds places, and explores maps.")
    Person(business, "Business", "Manages business profile information.")
    
    System(google_maps, "Google Maps", "The core system for mapping, routing, and search.")
    
    System_Ext(data_providers, "External Data Providers", "Supplies traffic, transit, and imagery data.")

    Rel(user, google_maps, "Requests map data, searches for places, gets directions")
    Rel(business, google_maps, "Submits and manages business information")
    Rel(google_maps, data_providers, "Ingests data from")
```

-----

#### 2\. Container Diagram

This diagram zooms into the Google Maps system, showing the major independently deployable components. The design is based on a distributed, microservices architecture to handle the scale and diversity of the data and queries.

**Description:**

  * **Client Application (Mobile/Web):** The user-facing application that renders maps, displays search results, and provides the interface for user interaction.
  * **API Gateway:** The single entry point for all client requests, handling authentication, rate limiting, and routing to the appropriate services.
  * **Mapping Service:** A high-throughput service that serves raster or vector map tiles to clients based on the requested location and zoom level.
  * **Geocoding Service:** Converts addresses and place names into geographic coordinates and vice-versa.
  * **Routing Service:** Calculates the best route between two or more points based on various travel modes (driving, walking, transit).
  * **Real-time Traffic Service:** Ingests live traffic data and provides real-time traffic updates to the Routing Service and Mapping Service.
  * **Search Service:** A sophisticated service that handles all queries for places of interest, businesses, and addresses.
  * **Place Details Service:** Provides detailed information about a specific location, including reviews, hours of operation, and photos.
  * **Geospatial Data Store:** A massive, distributed database optimized for storing geographical information like roads, buildings, and natural features.
  * **Search Index:** A highly optimized, full-text search index containing all searchable place and business information.

**Mermaid.js Code:**

```mermaid
C4Container
    title Container Diagram for Google Maps

    Person(user, "User")
    System_Ext(data_providers, "External Data Providers")

    System_Boundary(google_maps_boundary, "Google Maps System") {
        Container(client, "Client Application", "iOS, Android, Web App", "User interface for the platform.")
        Container(api_gateway, "API Gateway", "Go/NGINX", "Routes API calls and handles auth.")
        
        Container(map_service, "Mapping Service", "C++", "Serves map tiles and renders base maps.")
        Container(geocoding_service, "Geocoding Service", "Java", "Converts addresses to coordinates and vice-versa.")
        Container(routing_service, "Routing Service", "C++", "Calculates optimal routes and ETAs.")
        Container(traffic_service, "Real-time Traffic Service", "Python", "Ingests and processes live traffic data.")
        Container(search_service, "Search Service", "Java", "Handles all place and business search queries.")
        Container(place_service, "Place Details Service", "Node.js", "Provides detailed info for a specific place.")

        ContainerDb(geospatial_db, "Geospatial Data Store", "Custom Distributed DB", "Stores road networks, building footprints, etc.")
        ContainerDb(search_index, "Search Index", "Custom Index", "Optimized for full-text search on places.")
        ContainerDb(traffic_db, "Traffic Data Store", "Time-series DB", "Stores historical and real-time traffic data.")
    }
    
    Rel(user, client, "Uses")
    Rel(client, api_gateway, "Makes API calls to", "HTTPS")

    Rel(api_gateway, map_service, "Routes map requests to")
    Rel(api_gateway, geocoding_service, "Routes geocoding requests to")
    Rel(api_gateway, routing_service, "Routes routing requests to")
    Rel(api_gateway, search_service, "Routes search requests to")
    Rel(api_gateway, place_service, "Routes place detail requests to")

    Rel(map_service, geospatial_db, "Reads map data from")
    Rel(geocoding_service, geospatial_db, "Queries location data from")
    Rel(routing_service, geospatial_db, "Queries road graph from")
    Rel(routing_service, traffic_service, "Gets real-time traffic data from")
    Rel(traffic_service, data_providers, "Ingests data from")
    Rel(traffic_service, traffic_db, "Saves data to")
    Rel(search_service, search_index, "Queries for matching places in")
    Rel(search_service, place_service, "Gets details for search results from")
```

-----

#### 3\. Component Diagram (Routing Service)

This diagram focuses on the internal components of the **Routing Service** container, illustrating how it calculates a route and an estimated time of arrival.

**Description:**

  * **API Controller:** The entry point for the Routing Service. It receives a request from the API Gateway with start, end, and travel mode.
  * **Graph Extractor:** A component that retrieves a subset of the global road network graph from the Geospatial Data Store, focusing on the area between the origin and destination.
  * **Routing Engine:** The core component that uses a pathfinding algorithm (e.g., A\*) to find the shortest or fastest path on the extracted graph.
  * **ETA Calculator:** A component that takes the calculated path and uses real-time and historical traffic data from the Traffic Service to determine a precise estimated time of arrival.
  * **Route Formatter:** A component that converts the calculated path into a human-readable format with turn-by-turn directions and milestones.

**Mermaid.js Code:**

```mermaid
C4Component
    title Component Diagram for Routing Service

    Container_Ext(api_gateway, "API Gateway")
    Container_Ext(geospatial_db, "Geospatial Data Store")
    Container_Ext(traffic_service, "Real-time Traffic Service")
    
    Container_Boundary(routing_service, "Routing Service") {
        Component(api_controller, "API Controller", "REST Endpoint", "Receives routing requests.")
        Component(graph_extractor, "Graph Extractor", "Query Component", "Retrieves relevant road segments.")
        Component(routing_engine, "Routing Engine", "Algorithm Component", "Finds the optimal path.")
        Component(eta_calculator, "ETA Calculator", "Prediction Model", "Calculates estimated travel time.")
        Component(route_formatter, "Route Formatter", "Data Transformation", "Formats the final route response.")
    }
    
    Rel(api_gateway, api_controller, "Sends routing request to", "HTTPS")
    Rel(api_controller, graph_extractor, "Passes origin and destination to")
    Rel(graph_extractor, geospatial_db, "Queries road graph from")
    Rel(graph_extractor, routing_engine, "Passes relevant graph data to")
    Rel(routing_engine, eta_calculator, "Passes raw path to")
    Rel(eta_calculator, traffic_service, "Queries for real-time traffic data from")
    Rel(eta_calculator, route_formatter, "Passes path and ETA to")
    Rel(route_formatter, api_controller, "Returns final route to")
```

-----

### Architecture Decision Record

#### ADR 1: Use a Specialized Geospatial Database for Scalable Mapping and Routing

**Status:** Proposed

**Context:**
A mapping service like Google Maps handles a massive scale of geospatial data, including road networks, points of interest, building footprints, and real-time location updates. The queries against this data are highly specialized, involving proximity searches, geometric operations, and graph traversal for routing. A traditional relational database is ill-suited to handle this volume and complexity efficiently, leading to slow query times and poor scalability.

**Decision:**
We will use a specialized, distributed **Geospatial Data Store** as the primary source of truth for all map-related data. This system is designed from the ground up to handle geographical information. It will use a spatial partitioning scheme (like a geohash grid or quadtree) to index the data, allowing for ultra-fast queries based on location, bounding boxes, and other spatial predicates. This database will also be a graph data structure to facilitate efficient pathfinding for the routing service.

**Consequences:**

  * **Positive:**

      * **High Performance:** Queries such as "find all restaurants within a 5-mile radius" or "calculate the fastest route" will be extremely fast due to the index optimization.
      * **Scalability:** The distributed nature of the database allows for horizontal scaling. We can add more nodes to store and serve a larger volume of map data.
      * **Data Integrity:** The database is designed to handle the unique properties of geospatial data, ensuring the integrity and accuracy of coordinates and relationships.

  * **Negative:**

      * **Increased Complexity:** Implementing and operating a custom or specialized distributed geospatial database is a significant engineering effort. It requires a dedicated team to manage data ingestion, indexing, and replication.
      * **Cost:** Specialized infrastructure may be more expensive than using off-the-shelf relational or NoSQL databases.
      * **Learning Curve:** The development team needs to acquire specific expertise in geospatial data structures and algorithms.

**Alternatives Considered:**

  * **Relational Database with Spatial Extensions:** Using a database like PostgreSQL with the PostGIS extension. While this is a powerful and widely-used solution, it may struggle with the massive write volume and real-time query load of a global-scale service. The performance of a single database would eventually become a bottleneck. This was rejected because it doesn't meet the high-throughput requirements.
  * **General-Purpose NoSQL Database:** Using a database like MongoDB or Cassandra with basic geospatial capabilities. While these are more scalable than a single relational database, they are not as optimized for complex, low-latency graph traversal and spatial operations required for advanced routing and analytics. This was rejected for the same reason.
