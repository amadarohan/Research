System Design for: 'Instagram'

This document outlines the architectural design for a scalable photo and video sharing platform like Instagram. The design focuses on handling a massive volume of user-generated content, a high rate of uploads and a much higher rate of reads (feed viewing), while ensuring low latency and high availability.

### C4 Model Diagrams

#### 1\. System Context Diagram

The System Context diagram provides a high-level view of the Instagram system and its interactions with external users and systems. It shows the core platform interacting with users, third-party services for social logins, and CDNs for content delivery.

**Description:**

  * **User:** A person who creates a profile, uploads photos/videos, views their feed, and interacts with other users (likes, comments).
  * **Instagram (System in Scope):** The main platform that manages all user content and interactions.
  * **Third-Party Login Service:** An external system like Facebook or Google that provides authentication services for users.
  * **Content Delivery Network (CDN):** A distributed network of servers that caches static content (like photos and videos) to deliver it to users with low latency.

**Mermaid.js Code:**

```mermaid
C4Context
    title System Context Diagram for Instagram

    Person(user, "User", "A person who shares and views photos/videos.")

    System(instagram, "Instagram", "The core social media platform.")

    System_Ext(third_party_login, "Third-Party Login Service", "Facebook/Google for authentication.")
    System_Ext(cdn, "Content Delivery Network", "A global network to serve media content.")

    Rel(user, instagram, "Uses via Mobile App/Web")
    Rel(instagram, third_party_login, "Authenticates users via")
    Rel(instagram, cdn, "Sends media to")
    Rel(user, cdn, "Fetches media content from")
```

#### 2\. Container Diagram

This diagram zooms into the Instagram system, showing the major containers. The design leverages a microservices architecture to manage different functional domains and a tiered storage approach for content.

**Description:**

  * **Mobile/Web Client:** The application (iOS, Android, or web) that users interact with. It communicates with the API Gateway.
  * **API Gateway:** The single entry point for all client requests. It handles authentication, rate limiting, and routes requests to the appropriate microservices.
  * **Upload Service:** A microservice dedicated to handling photo and video uploads. It processes the content, generates multiple resolutions, and stores them.
  * **User Service:** Manages user profiles, authentication, and follow relationships. It has a relational database for user data.
  * **Content Service:** Manages metadata for all photos and videos (e.g., captions, hashtags). It's responsible for interacting with the blob storage and CDN.
  * **Social Graph Service:** A specialized service that manages the follower/following relationships. This is a critical component for feed generation and is often a separate graph database.
  * **Feed Service:** A core service that generates and serves personalized feeds for users. It aggregates content from the Social Graph and Content services.
  * **Activity Service:** Handles likes, comments, and other user interactions. It pushes notifications and updates to other services.
  * **Media Store (Blob Storage):** A highly scalable, object-based storage system (e.g., AWS S3, Google Cloud Storage) for storing raw and processed photos/videos.
  * **CDN (Content Delivery Network):** A global network that caches and serves static media content to users, reducing latency and load on the primary services.
  * **Databases (Polyglot Persistence):** Each microservice has its own dedicated database. The Social Graph service would use a graph database, while the User and Content services would likely use a relational database or a key-value store.

**Mermaid.js Code:**

```mermaid
C4Container
    title Container Diagram for Instagram

    Person(user, "User")
    System_Ext(third_party_login, "Third-Party Login")
    System_Ext(cdn, "Content Delivery Network")

    System_Boundary(instagram_boundary, "Instagram") {
        Container(mobile_client, "Mobile/Web Client", "iOS, Android, Web App", "User interface for the platform.")
        Container(api_gateway, "API Gateway", "Go/Node.js", "Routes API calls and handles auth.")
        
        Container(user_service, "User Service", "Java/Spring Boot", "Manages users and profiles.")
        Container(upload_service, "Upload Service", "Python/Flask", "Handles media uploads and processing.")
        Container(content_service, "Content Service", "Java", "Manages media metadata and hashtags.")
        Container(social_graph_service, "Social Graph Service", "Scala/Akka", "Manages follower relationships.")
        Container(feed_service, "Feed Service", "Go", "Generates and serves user feeds.")
        Container(activity_service, "Activity Service", "Python", "Handles likes, comments, and notifications.")

        ContainerDb(user_db, "User DB", "MySQL", "Stores user profiles.")
        ContainerDb(content_db, "Content DB", "Cassandra", "Stores media metadata.")
        ContainerDb(social_graph_db, "Social Graph DB", "Neo4j/Graph DB", "Stores follower relationships.")
        ContainerDb(media_store, "Media Store", "AWS S3/GCS", "Stores raw and processed media files.")
    }

    Rel(user, mobile_client, "Uses")
    Rel(mobile_client, api_gateway, "Makes API calls to", "HTTPS")

    Rel(api_gateway, user_service, "Routes API calls to")
    Rel(api_gateway, upload_service, "Routes API calls to")
    Rel(api_gateway, content_service, "Routes API calls to")
    Rel(api_gateway, social_graph_service, "Routes API calls to")
    Rel(api_gateway, feed_service, "Routes API calls to")
    Rel(api_gateway, activity_service, "Routes API calls to")

    Rel(user_service, user_db, "Reads/writes to")
    Rel(upload_service, media_store, "Saves media to")
    Rel(content_service, content_db, "Reads/writes to")
    Rel(social_graph_service, social_graph_db, "Reads/writes to")

    Rel(upload_service, content_service, "Notifies of new content", "Async Messaging")
    Rel(content_service, cdn, "Pushes media to")
    Rel(feed_service, social_graph_service, "Queries for followed users")
    Rel(feed_service, content_service, "Queries for content from followed users")
    Rel(mobile_client, cdn, "Fetches media content from", "HTTPS")
```

#### 3\. Component Diagram (Feed Service)

This diagram focuses on the internal components of the **Feed Service** container, illustrating how it generates a user's feed.

**Description:**

  * **API Controller:** The entry point for the Feed Service. It receives requests from the API Gateway for a user's feed.
  * **Feed Generator:** A component that orchestrates the feed creation process. It pulls data from various sources to build a personalized timeline.
  * **Social Graph Client:** A component that communicates with the Social Graph Service to retrieve a list of users the current user follows.
  * **Content Store Client:** A component that communicates with the Content Service to retrieve recent content for the list of followed users.
  * **Timeline Aggregator:** A component that takes the content retrieved from various sources, merges it, and sorts it by a specific metric (e.g., reverse chronological order, or a relevance score).
  * **Feed Cache:** A fast, in-memory cache (like Redis) that stores pre-generated feeds for quick retrieval, especially for users with many followers. This is a critical optimization to handle the high read-to-write ratio.

**Mermaid.js Code:**

```mermaid
C4Component
    title Component Diagram for Feed Service

    Container(api_gateway, "API Gateway", "Go/Node.js")
    Container_Ext(social_graph_service, "Social Graph Service")
    Container_Ext(content_service, "Content Service")
    Container_Ext(activity_service, "Activity Service")
    Container_Ext(feed_cache, "Feed Cache", "Redis Cluster")

    Container_Boundary(feed_service, "Feed Service") {
        Component(api_controller, "API Controller", "REST Endpoint", "Receives user feed requests.")
        Component(feed_generator, "Feed Generator", "Orchestrator", "Generates the user's feed.")
        Component(social_graph_client, "Social Graph Client", "gRPC Client", "Fetches followees from Social Graph Service.")
        Component(content_store_client, "Content Store Client", "gRPC Client", "Fetches content from Content Service.")
        Component(timeline_aggregator, "Timeline Aggregator", "Logic Component", "Merges and sorts the content.")
    }

    Rel(api_gateway, api_controller, "Requests feed from", "HTTPS")
    Rel(api_controller, feed_cache, "Checks for cached feed in")
    Rel(feed_cache, api_controller, "Returns cached feed if exists")
    Rel(api_controller, feed_generator, "Delegates to generate feed")
    Rel(feed_generator, social_graph_client, "Queries for followed users")
    Rel(social_graph_client, social_graph_service, "Retrieves follower list from")
    Rel(feed_generator, content_store_client, "Queries for content from followed users")
    Rel(content_store_client, content_service, "Retrieves content metadata from")
    Rel(feed_generator, timeline_aggregator, "Passes content to be aggregated")
    Rel(timeline_aggregator, feed_cache, "Writes generated feed to")
    Rel(timeline_aggregator, api_controller, "Returns aggregated feed to")
```

### Architecture Decision Record

#### ADR 1: Use a Fan-out on Read Strategy for the User Feed

**Status:** Proposed

**Context:**
The core functionality of Instagram is serving a user's personalized feed. The system has an extremely high read-to-write ratio; a single photo upload (a write) can be viewed by millions of followers (reads). A fan-out on write model, where a post is pushed to all followers' timelines at the time of upload, becomes inefficient and can cause write amplification at a massive scale. A single user with millions of followers could overload the system with a single post. A fan-out on read model, where the feed is generated at the time of the request, is more scalable for this specific workload.

**Decision:**
We will implement a **Fan-out on Read** strategy for generating the user feed. When a user requests their feed, the Feed Service will:

1.  Fetch the user's list of followed users from the Social Graph Service.
2.  Query the Content Service to retrieve recent content from those followed users.
3.  Aggregate and sort the content to form the final timeline.
4.  Cache the generated feed for subsequent requests to reduce latency.

**Consequences:**

  * **Positive:**

      * **Scalability:** The system scales effectively with the number of followers. A user with millions of followers does not cause a large number of writes for a single post. The reads are distributed across the system, and the cost is paid by the reader, not the writer.
      * **Simplicity:** The write path is simple and efficient. The Upload Service only needs to write the content and metadata once, without needing to fan it out.
      * **Freshness:** The feed is always fresh and reflects the most recent activity at the time of the request.
      * **Customization:** It's easier to implement complex ranking algorithms (e.g., personalized, non-chronological feeds) because the entire timeline is generated dynamically.

  * **Negative:**

      * **Increased Read Latency:** For users with a large number of followers or who follow many people, generating the feed on the fly can be slow. This is mitigated by a robust caching strategy and using fast, optimized data stores.
      * **Load on Read:** The feed generation process can be computationally expensive and resource-intensive, placing a heavy load on the Social Graph and Content services during peak read times. This requires careful load balancing and provisioning.
      * **Complexity:** The Feed Service becomes a complex orchestrator, responsible for querying multiple services and handling potential failures or inconsistencies. The caching strategy also adds complexity.

**Alternatives Considered:**

  * **Fan-out on Write:** In this model, when a user uploads content, it is immediately pushed to the inboxes or timelines of all their followers. This leads to extremely low read latency for the feed (just a simple database lookup). However, it's not suitable for a large-scale system like Instagram due to:
      * **Write Amplification:** A single post from a user with millions of followers would result in millions of database writes, potentially overwhelming the system.
      * **Storage Overhead:** Requires a separate "timeline" or "inbox" for every user, which can consume significant storage. It was rejected because the write load would be unmanageable at scale.
