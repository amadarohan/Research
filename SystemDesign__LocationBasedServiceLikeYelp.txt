System Design for: 'Location-Based Service like Yelp'

This document outlines the architectural design for a scalable, location-based service similar to Yelp. The system is designed to handle user-generated content (reviews, photos), discoverability of local businesses, and a high volume of search queries, all with a focus on real-time and geographically relevant data.

### C4 Model Diagrams

#### 1\. System Context Diagram

The System Context diagram provides a high-level view of the Location-Based Service and its interactions with external users and systems. It shows the core platform interacting with users, businesses, and third-party map providers.

**Description:**

  * **User:** A person who searches for local businesses, views reviews, submits their own reviews and photos, and can check in to a location.
  * **Business Owner:** A person who claims a business profile to manage information, respond to reviews, and run promotions.
  * **Location-Based Service (System in Scope):** The central platform that stores and serves business data, reviews, and provides search and discovery functionalities.
  * **Third-Party Map Service:** An external system (e.g., Google Maps, Apple Maps) that provides geocoding, mapping, and routing services.

**Mermaid.js Code:**

```mermaid
C4Context
    title System Context Diagram for Location-Based Service

    Person(user, "User", "Searches for places, writes reviews, and uploads photos.")
    Person(business_owner, "Business Owner", "Manages business profile and responds to reviews.")
    
    System(lbs, "Location-Based Service", "The core system for discovering and reviewing local businesses.")
    
    System_Ext(map_service, "Third-Party Map Service", "Provides mapping, routing, and geocoding.")

    Rel(user, lbs, "Submits queries to, uploads content to")
    Rel(business_owner, lbs, "Manages business profile on")
    Rel(lbs, map_service, "Requests map data and geocoding from")
    Rel(user, map_service, "Views maps and directions from", "Via LBS client")
```

-----

#### 2\. Container Diagram

This diagram zooms into the Location-Based Service, showing the major independently deployable components. The design uses a microservices architecture to handle the diverse functionalities.

**Description:**

  * **Mobile/Web Client:** The application (iOS, Android, or web) that users and business owners interact with. It communicates with the API Gateway.
  * **API Gateway:** The single entry point for all client requests. It handles authentication, rate limiting, and routes requests to the appropriate microservices.
  * **User Service:** A microservice that manages user profiles, authentication, and user data. It has its own relational database.
  * **Business Service:** A microservice that manages business profiles, including name, address, hours, and categories. It needs a highly scalable database.
  * **Content Service:** A microservice that handles user-generated content, such as reviews and photos. It stores review text in a database and photos in an object store.
  * **Search Service:** The core search functionality. It takes a user's query and location and returns relevant businesses. This component relies on a highly optimized search index.
  * **Ranking Service:** A component that scores search results based on a multitude of factors, including relevance, rating, distance, and user history.
  * **Geospatial Index:** A specialized data store optimized for spatial queries (e.g., "find all businesses within 5 miles of this location").
  * **Search Index:** A highly scalable index (e.g., Elasticsearch or a custom solution) for text-based search queries on business names, reviews, and categories.
  * **Object Store:** A highly scalable blob storage system (e.g., AWS S3, Google Cloud Storage) for storing photos and other media.

**Mermaid.js Code:**

```mermaid
C4Container
    title Container Diagram for Location-Based Service

    Person(user, "User")
    Person(business_owner, "Business Owner")
    System_Ext(map_service, "Third-Party Map Service")
    
    System_Boundary(lbs_boundary, "Location-Based Service") {
        Container(mobile_client, "Mobile/Web Client", "iOS, Android, Web App", "User interface for the platform.")
        Container(api_gateway, "API Gateway", "Go/NGINX", "Routes API calls and handles auth.")
        
        Container(user_service, "User Service", "Java", "Manages user profiles and authentication.")
        Container(business_service, "Business Service", "Python", "Manages business profiles and details.")
        Container(content_service, "Content Service", "Node.js", "Handles reviews and photo uploads.")
        Container(search_service, "Search Service", "Java", "Handles business search and discovery.")
        Container(ranking_service, "Ranking Service", "Python/TensorFlow", "Ranks search results.")

        ContainerDb(user_db, "User DB", "MySQL", "Stores user profiles.")
        ContainerDb(business_db, "Business DB", "Cassandra", "Stores business details.")
        ContainerDb(review_db, "Review DB", "PostgreSQL", "Stores review text and ratings.")
        ContainerDb(geo_index, "Geospatial Index", "Elasticsearch/PostGIS", "Optimized for spatial queries.")
        ContainerDb(search_index, "Search Index", "Elasticsearch", "Optimized for text-based search.")
        ContainerDb(object_store, "Object Store", "AWS S3/GCS", "Stores photos and media.")
    }
    
    Rel(user, mobile_client, "Uses")
    Rel(business_owner, mobile_client, "Uses")
    Rel(mobile_client, api_gateway, "Makes API calls to", "HTTPS")

    Rel(api_gateway, user_service, "Routes API calls to")
    Rel(api_gateway, business_service, "Routes API calls to")
    Rel(api_gateway, content_service, "Routes API calls to")
    Rel(api_gateway, search_service, "Routes API calls to")

    Rel(user_service, user_db, "Reads/writes to")
    Rel(business_service, business_db, "Reads/writes to")
    Rel(content_service, review_db, "Reads/writes to")
    Rel(content_service, object_store, "Saves photos to")
    Rel(search_service, geo_index, "Queries for location-based results")
    Rel(search_service, search_index, "Queries for text-based results")
    Rel(search_service, ranking_service, "Passes results for ranking")
    Rel(ranking_service, search_service, "Returns ranked results to")
```

-----

#### 3\. Component Diagram (Search Service)

This diagram focuses on the internal components of the **Search Service** container, illustrating how it handles a user's search query.

**Description:**

  * **API Controller:** The entry point for the Search Service. It receives a search query from the API Gateway, including the user's location and search terms.
  * **Query Parser:** A component that takes the raw query string and extracts key information, such as business type ("restaurants"), name ("The Corner Cafe"), and location details ("near me").
  * **Geospatial Client:** A component that queries the Geospatial Index to find businesses within the user's defined search area.
  * **Search Index Client:** A component that queries the Search Index for businesses that match the extracted text terms.
  * **Results Aggregator:** A component that combines the results from both the Geospatial Client and the Search Index Client. It de-duplicates entries and forms a unified list of candidate businesses.
  * **Ranking Service Client:** A component that sends the unified list of businesses to the Ranking Service for scoring and sorting based on relevance.

**Mermaid.js Code:**

```mermaid
C4Component
    title Component Diagram for Search Service

    Container(api_gateway, "API Gateway")
    Container_Ext(geo_index, "Geospatial Index", "Elasticsearch")
    Container_Ext(search_index, "Search Index", "Elasticsearch")
    Container_Ext(ranking_service, "Ranking Service")

    Container_Boundary(search_service, "Search Service") {
        Component(api_controller, "API Controller", "REST Endpoint", "Receives search requests.")
        Component(query_parser, "Query Parser", "NLP/Lexer", "Extracts terms and location from query.")
        Component(geo_client, "Geospatial Client", "Elasticsearch Client", "Queries the geospatial index.")
        Component(search_client, "Search Index Client", "Elasticsearch Client", "Queries the main search index.")
        Component(results_aggregator, "Results Aggregator", "Logic Component", "Combines results from multiple sources.")
        Component(ranking_client, "Ranking Service Client", "gRPC Client", "Sends results for ranking.")
    }
    
    Rel(api_gateway, api_controller, "Sends search query to", "HTTPS")
    Rel(api_controller, query_parser, "Passes query to")
    Rel(query_parser, geo_client, "Sends geospatial query to")
    Rel(geo_client, geo_index, "Queries for nearby businesses")
    Rel(query_parser, search_client, "Sends text search query to")
    Rel(search_client, search_index, "Queries for matching businesses")
    Rel(geo_client, results_aggregator, "Passes location-based results to")
    Rel(search_client, results_aggregator, "Passes text-based results to")
    Rel(results_aggregator, ranking_client, "Sends combined results for ranking")
    Rel(ranking_client, ranking_service, "Requests ranking from")
    Rel(ranking_client, api_controller, "Returns ranked results to")
```

-----

### Architecture Decision Record

#### ADR 1: Use a Dual-Indexing Strategy for Text and Geospatial Search

**Status:** Proposed

**Context:**
A core requirement of a location-based service is to perform two distinct types of searches efficiently:

1.  **Text Search:** Finding businesses based on name, category, or review content (e.g., "best Italian food").
2.  **Geospatial Search:** Finding businesses within a specific geographical area (e.g., "restaurants near me").
    A single, monolithic database or index is unlikely to be optimized for both of these demanding query types. Using separate, purpose-built indices will provide superior performance and scalability.

**Decision:**
We will implement a **dual-indexing strategy**, utilizing two separate and highly optimized indices:

1.  **A Geospatial Index:** This index will store the location coordinates of every business. It will be a highly performant, in-memory or SSD-backed index designed to handle complex geospatial queries like proximity searches (`find all points within a 5-mile radius`) and boundary searches (`is this point inside a specific neighborhood?`).
2.  **A Full-Text Search Index:** This index will store all business data that is searchable by text, including names, descriptions, categories, and review content. It will be a distributed, inverted index (like Elasticsearch or Apache Solr) optimized for fast, complex, text-based queries.

When a user performs a search, the **Search Service** will run a query against both indices in parallel. The results will then be aggregated and ranked before being returned to the user.

**Consequences:**

  * **Positive:**

      * **Performance:** Queries for both text and location will be extremely fast as they are handled by specialized, purpose-built systems. This leads to a low-latency user experience.
      * **Scalability:** Each index can be scaled independently. If the volume of text reviews grows, we can scale the Full-Text Search Index without affecting the Geospatial Index, and vice versa.
      * **Flexibility:** This architecture allows for advanced search features, such as combining location and text-based filters in a single query (e.g., "find sushi restaurants near me that have a high rating").

  * **Negative:**

      * **Increased Complexity:** This design requires managing and synchronizing two separate data stores. We need a reliable mechanism to ensure that when a new business is added or updated, both the Geospatial and Full-Text indices are updated correctly and consistently.
      * **Data Redundancy:** Some data (like business names and IDs) will be duplicated across both indices, which slightly increases storage requirements.
      * **Operational Overhead:** We have to maintain and monitor two different types of databases, each with its own scaling and operational considerations.

**Alternatives Considered:**

  * **Single Relational Database with Geospatial Extensions:** Using a database like PostgreSQL with the PostGIS extension. While this is a viable option for smaller-scale systems, it is unlikely to scale to Yelp's level of traffic and data volume. The performance of a single database would eventually become a bottleneck for both query types. This was rejected because it doesn't meet the high-throughput requirements.
  * **Single NoSQL Database:** Using a single NoSQL database. While some NoSQL databases support geospatial queries, they are generally not as optimized for complex, real-time text search and vice-versa. Trying to force a single solution to do both tasks well would likely result in compromises in performance for one or both. This was rejected for the same reasons.
