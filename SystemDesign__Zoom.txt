System Design for: 'Zoom'

This document outlines the architectural design for a scalable and real-time video conferencing platform like Zoom. The system is designed to handle a massive volume of concurrent users, provide low-latency audio/video streaming, and manage features like screen sharing, chat, and large-scale webinars, all while ensuring high reliability and quality.

### C4 Model Diagrams

#### 1\. System Context Diagram

The System Context diagram provides a high-level view of the Zoom system and its interactions with external users and systems. It shows the core platform interacting with meeting participants, external phone systems, and third-party calendar services.

**Description:**

  * **User:** A person who joins or hosts a video conference, either as a participant or a viewer.
  * **Zoom System (System in Scope):** The central platform that facilitates all video, audio, and data communication.
  * **External Calendar Service:** A third-party system (e.g., Google Calendar, Outlook) used for scheduling meetings and sending invites.
  * **External Phone System:** A third-party system that allows users to join meetings via a phone call.

**Mermaid.js Code:**

```mermaid
C4Context
    title System Context Diagram for Zoom

    Person(user, "User", "Hosts or joins a video conference.")
    
    System(zoom_system, "Zoom", "The core system for video conferencing.")
    
    System_Ext(calendar_service, "External Calendar Service", "Schedules meetings and sends invites.")
    System_Ext(phone_system, "External Phone System", "Allows users to join via phone.")

    Rel(user, zoom_system, "Connects to and participates in a meeting on")
    Rel(zoom_system, calendar_service, "Integrates with to schedule meetings")
    Rel(zoom_system, phone_system, "Allows dial-in access via")
```

-----

#### 2\. Container Diagram

This diagram zooms into the Zoom system, showing the major independently deployable components. The design is based on a distributed, microservices architecture with a focus on real-time media processing.

**Description:**

  * **Client Application (Desktop/Mobile/Web):** The user-facing application that captures and renders audio/video, and provides the interface for meeting controls.
  * **API Gateway:** The single entry point for all client requests, handling authentication, and routing to various backend services.
  * **Signaling Service:** A critical service that manages the connection and state of each meeting. It handles user joins/leaves, chat messages, and participant metadata. It does not handle media data.
  * **Media Ingress/Egress Service:** A high-throughput service that handles the secure ingestion of audio/video streams from participants and the delivery of aggregated streams back to them.
  * **Media Router/Mixer:** A core component that receives multiple media streams, processes them (e.g., mixing audio, forwarding video), and routes the final streams to the correct participants.
  * **Meeting Service:** Manages the lifecycle of a meeting, including creation, scheduling, and security settings.
  * **Chat Service:** Handles all in-meeting and persistent chat messages.
  * **User Service:** Manages user profiles, authentication, and contact lists.
  * **Media Relay Nodes:** A global network of distributed servers that reduce latency by placing media processing closer to users. This is a critical component for quality.
  * **Database:** A data store for meeting metadata, user profiles, and chat history.
  * **Load Balancer:** Distributes incoming media connections to the nearest available Media Relay Node.

**Mermaid.js Code:**

```mermaid
C4Container
    title Container Diagram for Zoom

    Person(user, "User")
    
    System_Boundary(zoom_system_boundary, "Zoom System") {
        Container(client, "Client Application", "Desktop, Mobile, Web App", "Captures and renders audio/video.")
        Container(api_gateway, "API Gateway", "Go/NGINX", "Routes API calls and handles auth.")
        Container(signaling_service, "Signaling Service", "Java", "Manages meeting state and participant metadata.")
        Container(media_ingress_egress, "Media Ingress/Egress Service", "C++", "Handles secure media stream ingestion and delivery.")
        Container(media_router, "Media Router/Mixer", "C++", "Processes and routes media streams.")
        Container(meeting_service, "Meeting Service", "Python", "Manages meeting lifecycle and settings.")
        Container(chat_service, "Chat Service", "Node.js", "Handles meeting and persistent chat.")
        Container(user_service, "User Service", "Java", "Manages user profiles and authentication.")
        Container(media_relay_nodes, "Media Relay Nodes", "C++ Servers", "A global network for media processing.")
        
        ContainerDb(database, "Database", "Cassandra/PostgreSQL", "Stores user, meeting, and chat metadata.")
        Container(load_balancer, "Load Balancer", "NGINX/HAProxy", "Distributes media connections to relay nodes.")
    }
    
    Rel(user, client, "Uses")
    Rel(client, api_gateway, "Makes API calls to", "HTTPS")
    Rel(client, load_balancer, "Connects to media streams via")
    
    Rel(api_gateway, signaling_service, "Routes signaling requests to")
    Rel(api_gateway, meeting_service, "Routes meeting setup requests to")
    Rel(api_gateway, chat_service, "Routes chat requests to")
    Rel(api_gateway, user_service, "Routes auth requests to")
    
    Rel(load_balancer, media_relay_nodes, "Routes media traffic to")
    Rel(media_relay_nodes, media_ingress_egress, "Sends media streams to")
    Rel(media_ingress_egress, media_router, "Feeds media streams to")
    Rel(media_router, media_ingress_egress, "Sends processed streams back to")
    Rel(media_ingress_egress, client, "Delivers streams to", "UDP/TCP")
```

-----

#### 3\. Component Diagram (Media Router/Mixer)

This diagram focuses on the internal components of the **Media Router/Mixer** container, illustrating how it handles and processes media streams for a single meeting.

**Description:**

  * **Ingestion Port:** Receives a media stream (audio and/or video) from a participant via the Media Ingress/Egress service.
  * **Audio Processor:** A component that handles audio streams. It can perform functions like noise cancellation, echo suppression, and mixing multiple audio streams into one.
  * **Video Processor:** A component that handles video streams. It can perform functions like transcoding, resizing, and dynamically selecting which video stream to send to each participant based on the speaker.
  * **Egress Port:** Sends the processed and aggregated audio/video streams to the participants via the Media Ingress/Egress service.
  * **Session Manager:** A component that maintains the state of the meeting, including which participants are connected, their media stream properties, and the current speaker.

**Mermaid.js Code:**

```mermaid
C4Component
    title Component Diagram for Media Router/Mixer

    Container(media_ingress_egress, "Media Ingress/Egress Service")
    
    Container_Boundary(media_router_boundary, "Media Router/Mixer") {
        Component(ingestion_port, "Ingestion Port", "Stream Receiver", "Receives media streams from participants.")
        Component(audio_processor, "Audio Processor", "Logic Component", "Mixes and processes audio streams.")
        Component(video_processor, "Video Processor", "Logic Component", "Transcodes and selects video streams.")
        Component(egress_port, "Egress Port", "Stream Sender", "Sends processed streams to participants.")
        Component(session_manager, "Session Manager", "Stateful Logic", "Manages meeting state and participants.")
    }
    
    Rel(media_ingress_egress, ingestion_port, "Sends raw media streams to")
    Rel(ingestion_port, audio_processor, "Feeds audio stream to")
    Rel(ingestion_port, video_processor, "Feeds video stream to")
    Rel(ingestion_port, session_manager, "Updates participant status in")
    Rel(audio_processor, egress_port, "Sends processed audio to")
    Rel(video_processor, egress_port, "Sends processed video to")
    Rel(egress_port, media_ingress_egress, "Sends final streams to")
    Rel(session_manager, audio_processor, "Provides routing info to")
    Rel(session_manager, video_processor, "Provides routing info to")
```

-----

### Architecture Decision Record

#### ADR 1: Use a Mesh vs. SFU vs. MCU Architecture for Media Routing

**Status:** Proposed

**Context:**
A key design decision for a real-time video conferencing system is how to route media streams between participants. The choice of architecture directly impacts latency, server load, and video quality. There are three primary models:

1.  **Mesh:** Each participant sends their video to every other participant. This is simple but doesn't scale well beyond a few users due to massive bandwidth consumption on the client side.
2.  **MCU (Multipoint Control Unit):** All streams are sent to a central server, which mixes them into a single stream and sends it back to each participant. This is computationally intensive for the server and introduces latency.
3.  **SFU (Selective Forwarding Unit):** Each participant sends their video to a central server, which then forwards the individual streams to other participants without mixing them. This is the model used by most modern, scalable systems.

**Decision:**
We will implement an **SFU (Selective Forwarding Unit) architecture**. Each participant will upload their audio and video streams to a designated Media Relay Node (the SFU). The SFU will then intelligently forward the individual streams of other participants to each client. This architecture provides the best balance of scalability, performance, and flexibility.

**Consequences:**

  * **Positive:**
      * **Scalability:** The SFU scales much better than the Mesh model, as client bandwidth consumption is limited to the number of participants displayed on the screen.
      * **Reduced Server Load:** Unlike the MCU, the SFU does not mix streams, which offloads a significant amount of CPU-intensive work to the clients.
      * **Flexibility:** The SFU can selectively choose which streams to forward (e.g., only the current speaker's video), optimizing bandwidth for clients with limited connectivity. This is a key feature for a responsive user experience.
  * **Negative:**
      * **Increased Complexity:** The SFU architecture is more complex to implement than a simple Mesh. It requires intelligent routing, stream prioritization, and robust handling of network jitter and packet loss.
      * **Single Point of Failure:** While distributed, if a single SFU server fails, all participants connected to it will be disconnected. This requires a robust failover mechanism.
      * **Latency:** While better than an MCU, there is still some latency introduced by routing through the SFU compared to a peer-to-peer (Mesh) connection.

**Alternatives Considered:**

  * **Mesh Architecture:** This model would be simple to implement for small meetings but would be unusable for meetings with more than a handful of participants due to the exponential increase in bandwidth required from each client. It was rejected because the system must be highly scalable.
  * **MCU (Multipoint Control Unit) Architecture:** This model is simple for clients, as they only receive one stream, but it is not scalable for the server. The computational resources required to mix hundreds or thousands of streams would be immense, making it prohibitively expensive and a significant bottleneck. It was rejected for scalability and cost reasons.
